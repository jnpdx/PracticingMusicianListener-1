/*
 * This is a helper that should be the interface to most of what the app does with VexFlow,
 * specifically using the EasyScore system
 *
 * Written as a global variable, but it does store some state information, since the notation should
 * only be done once
 */

VF = Vex.Flow;

//helper function
function concat(a, b) { return a.concat(b); }


var EasyScoreUtil = {

    //the current position that systems are being placed on the screen
    scorePositionX : 60,
    scorePositionY : 0,

    //gets set later with the current exercise (from notesFromKotlinNotationItems())
    exercise: null,

    //VexFlow variables that need to be stored
    vf : null,
    registry: null,

    //these three are just bind-ed functions
    score: null,
    voice: null,
    beam: null,

    //counter so that we can get an individual ID for each note
    noteIDNumber: 0,

    //array of systems (really measures...) that have been added to the screen
    //useful for getting placement information later
    systems: Array(),

    //setup the basic notation stuff
    setupOnElement: function(elementID) {
        this.vf = new Vex.Flow.Factory({
                renderer: {selector: elementID, width: 1100, height: 900}
                });

        this.registry = new VF.Registry();
        VF.Registry.enableDefaultRegistry(this.registry);

        this.score = this.vf.EasyScore({ throwOnError: true });

        this.voice = this.score.voice.bind(this.score);
        this.notes = this.score.notes.bind(this.score);
        this.beam = this.score.beam.bind(this.score);
    },

    //make a new system (measure) of a given width
    makeSystem: function (width) {

        var system = this.vf.System({ x: this.scorePositionX, y: this.scorePositionY, width: width, spaceBetweenStaves: 10 });
        this.scorePositionX += width;
        return system;
    },

    //helper function to get easy access to notes later on
    id: function (id) { return this.registry.getElementById(id); },

    //take a Kotlin ExerciseDescription and convert it to bars and notes for use here
    notesFromKotlinNotationItems : function(notes) {
            var rawNotes = Array() //just the raw notes, without bar numbers

            var bars = Array() //split up by bars

            //this is actually just the notes parameter we got on input, turned into an array
            var arrayOfNotes = notes.toArray()

            //total duration of the exercise
            var totalDuration = 0

            //store information for the current bar -- this will get added to bars later
            var currentBar = Array()

            //examine each note
            for (index in arrayOfNotes) {
                var item = arrayOfNotes[index]
                //console.log("Checking item " + item.constructor.name)

                //depending on what it is, we'll either add it to the current bar, or create a new bar
                switch(item.constructor.name) {
                    case "Barline":
                    bars.push(currentBar)
                    currentBar = Array()
                    break
                    case "Note":
                    var duration = function() {
                        switch(item.duration) {
                            case 1.0:
                            return "q"
                            default:
                            console.log("Duration error")
                            return "err"
                        }
                    }()
                    totalDuration += item.duration
                    //items.push( new VF.StaveNote({clef: "treble", keys: [item.textValue], duration: duration }) )
                    currentBar.push(item.textValue)

                    rawNotes.push(item)

                    break
                    default:
                    console.log("Not found " + item.constructor.name)
                    break
                }


            }

            //console.log("Came up with : " + items)

            return {
                rawNotes: rawNotes, //the notes, not split by bar (useful to find beat positions)
                bars: bars, //split by bar
                beats: totalDuration //total duration of the exercise
            }
        },

    //Take the current exercise (as generated by notesFromKotlinNotationItems) and notate it on the screen,
    notateExercise: function() {

        //TODO: make this dynamic
        this.score.set({ time: '4/4' });

        //scan through each bar
        for (barIndex in this.exercise.bars) {
            console.log("Making bar...")

            var measureWidth = 160;

            //if it's the first bar, it'll need extra space, since it has a clef and time/key sigs
            if (barIndex == 0) {
                measureWidth = 220;
            }

            var system = EasyScoreUtil.makeSystem(measureWidth);

            this.systems.push(system)

            var bar = this.exercise.bars[barIndex]

            console.log("Content: ")
            console.log(bar)


            var notesString = ""

            //take the notes and make a string that EasyScore can read, while giving each note a unique ID
            for (var noteIndex in bar) {
                var note = bar[noteIndex]

                if (noteIndex > 0) {
                    notesString += ","
                }
                notesString += note

                notesString += "[id=\"note" + this.noteIDNumber + "\"]"

                this.noteIDNumber++
            }

            //var notesString = bar.join(",")

            console.log(notesString)

            var stave = system.addStave({ voices: [this.voice(this.notes(notesString))] });

            //if it's the first bar, add the extra information
            if (barIndex == 0) {
                stave.addClef('treble')
                stave.addKeySignature("C")
                stave.addTimeSignature("4/4")
            }
        }

        //draw it to the screen
        this.vf.draw();
        VF.Registry.disableDefaultRegistry();
    },


    //given a certain beat, return the elements (notes) that surround it.
    //So, in a bar of quarter notes, 1.5 should return the first and second items, with
    //percent at 0.5
    getElementsForBeat: function(beat) {

            //current position to scan
            var currentPosition = 0

            //these will be the elements we store and return
            var beginningItemIndex = null
            var endingItemIndex = null

            //the beat positions of those elements
            var firstItemBeatPosition = 0
            var lastItemBeatPosition = 0

            //percentage between the elements that the beat exists in
            var percent = null

            console.log("Searching for beat " + beat + " in")
            console.log(this.exercise.rawNotes)

            for (index in this.exercise.rawNotes) {
                var item = this.exercise.rawNotes[index]

                var duration = item.duration

                if (currentPosition < beat) {
                    beginningItemIndex = index
                    endingItemIndex = index

                    firstItemBeatPosition = currentPosition
                    lastNoteBeatPosition = currentPosition
                } else {
                    if (beginningItemIndex == null) {
                        beginningItemIndex = index
                        firstItemBeatPosition = currentPosition
                    }
                    //set the end item index
                    endingItemIndex = index
                    lastItemBeatPosition = currentPosition

                    if (currentPosition >= beat) {
                        break
                    }
                }

                currentPosition += duration

            }

            var distanceBetween = lastItemBeatPosition - firstItemBeatPosition
            var beatDistanceFromFirstItem = beat - firstItemBeatPosition

            percent = beatDistanceFromFirstItem / distanceBetween

            if (percent < 0 || isNaN(percent)) percent = 0

            console.log("End pos: " + currentPosition)
            return {
                "currentItemIndex": beginningItemIndex, //item at or before the beat
                "nextItemIndex": endingItemIndex, //item after the beat
                "percent" : percent //percent that describes the distance
            }
     },

    //get the position (coordinates) for a certain beat
    getPositionForBeat: function(beat) {
        //get the elements on either side
        var ts = EasyScoreUtil.getElementsForBeat(beat)

        //use the ids to get the actual elements
        var currentItem = EasyScoreUtil.id("note" + ts.currentItemIndex)
        var nextItem = EasyScoreUtil.id("note" + ts.nextItemIndex)

        //find the middles of the items
        var distance = EasyScoreUtil.middlePositionOfItem(nextItem) - EasyScoreUtil.middlePositionOfItem(currentItem)
        var initialPos = EasyScoreUtil.middlePositionOfItem(currentItem)

        //account for the percent distance too
        return initialPos + distance * ts.percent

      },

    //helper function to find the middle of an item
     middlePositionOfItem: function(item) {
              return item.getAbsoluteX() + item.getBoundingBox().w / 2.0
      },

    //get the current staff
    //WARNING: currently just returns the first one
    getCurrentStave : function() {
        return this.systems[0].parts[0].stave
    },

    //draw the indicator line (blue line that shows current position)
    drawIndicatorLine: function(canvas, indicatorPosition) {

            var indicatorOverflow = 20

            var stave = EasyScoreUtil.getCurrentStave()

            var topY = stave.getYForLine(0) - indicatorOverflow
            var bottomY = stave.getYForLine(4) + indicatorOverflow

            if (canvas.getContext) {

            	   // use getContext to use the canvas for drawing
            	   var ctx = canvas.getContext('2d');

                   ctx.strokeStyle = '#4990E2';
                   ctx.lineWidth = 3;

            	   // Stroked triangle
            	   ctx.beginPath();
            	   ctx.moveTo(indicatorPosition,bottomY);
            	   ctx.lineTo(indicatorPosition,topY);
            	   ctx.closePath();
            	   ctx.stroke();

              }
        },

    //get the Y coordinate for feedback items
    getFeedbackYPosition : function() {
        return EasyScoreUtil.getCurrentStave().getBoundingBox().y + EasyScoreUtil.getCurrentStave().getBoundingBox().h
    },

    //draw feedback item at a given position
    drawFeedbackAtPosition(canvas,feedbackItemType,x,y) {

            var ctx = canvas.getContext('2d');

            ctx.font = "20px Arial"
            ctx.textBaseline = "top";
            ctx.fillText(feedbackItemType,x,y)

    },

}